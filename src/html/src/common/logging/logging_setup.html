<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.common.logging.logging_setup API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.common.logging.logging_setup</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import logging
import sys
from logging import handlers
import colorama     # type: ignore
from colorama import Fore, Back, Style

from common.logging.logging_constants import LoggingConstantsNamespace      # type: ignore

logging_constants = LoggingConstantsNamespace()


class FilterByModule(logging.Filter):
    &#34;&#34;&#34;
    custom filter class called FilterByModule that inherits from logging.Filter. The filter method of this class
    is called for each log record, and it returns True if the record should be allowed through, or False if it
    should be filtered out.
    &#34;&#34;&#34;

    def __init__(self, module_name) -&gt; None:
        super().__init__()
        self.module_name = module_name

    def filter(self, record):
        return not record.name.startswith(self.module_name)


class LoggingSetup:
    &#34;&#34;&#34;
    A class that sets up and configures logging for an application.

    Singleton Logger class. This class is only instantiated ONCE. It is to keep a consistent
    criteria for the logger throughout the application if need be called upon.
    It serves as the criteria for initiating logger for modules. It creates child loggers.
    It&#39;s important to note these are child loggers as any changes made to the root logger
    can be done.
    This class includes methods to set the log level of the root logger, add new loggers,
    and print logs of different levels (info, success, debug, exception, error, warning,
    and critical). It also includes methods to add and retrieve custom log level names.
    The SuccessLevel class is a custom log level used for success messages.

    Methods:
        - def get_console_handler(self):
            Defines a console handler to come out on the console
        - def get_file_handler(self):
            Defines a file handler to come out on the console.
        - def add_handlers(self, logger, handler_list: list):
            Adds handlers to the logger, checks first if handlers exist to avoid duplication
        - def get_logger(self, logger_name: str):
            Generates logger for use in the modules.
        - def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
            Sets ups a new logger
        - def set_debug_mode(self, debug_mode: bool):
            Function to set the root level logging to be debug level to be carried forward throughout
        - def get_log_level(self, level: int):
            Returns the log level legend
        - def add_level_name(self, level: int, level_name: str) -&gt; None:
            Outputs the received message to stdout
        - def get_level_name(self, level_name: str) -&gt; None:
            Outputs the received message to stdout
        - def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
            Filters log messages from a specific module and sets the logging level for that module
        - def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
            Outputs the received message to stdout.
    &#34;&#34;&#34;

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls.debug_mode = logging_constants.debug_mode_flag
            cls.formatter = logging.Formatter(logging_constants.default_logger_format)
            cls.log_file = logging_constants.log_filename

        return cls._instance

    def get_console_handler(self):
        &#34;&#34;&#34;
        Defines a console handler to come out on the console

        Returns:
            logging handler object : the console handler
        &#34;&#34;&#34;
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(self.formatter)
        console_handler.name = &#34;consoleHandler&#34;
        return console_handler

    def get_file_handler(self):
        &#34;&#34;&#34;
        Defines a file handler to come out on the console.

        Returns:
            logging handler object : the console handler
        &#34;&#34;&#34;
        file_handler = handlers.RotatingFileHandler(
            &#34;./output/logging_logs/&#34; + self.log_file, maxBytes=5000, backupCount=1
        )
        file_handler.setFormatter(self.formatter)
        file_handler.name = &#34;fileHandler&#34;
        return file_handler

    def add_handlers(self, logger, handler_list: list):
        &#34;&#34;&#34;
        Adds handlers to the logger, checks first if handlers exist to avoid
        duplication

        Args:
            logger: Logger to check handlers&#39;
            handler_list: list of handlers to add
        &#34;&#34;&#34;
        existing_handler_names = []
        for existing_handler in logger.handlers:
            existing_handler_names.append(existing_handler.name)

        for new_handler in handler_list:
            if new_handler.name not in existing_handler_names:
                logger.addHandler(new_handler)

    def get_logger(self, logger_name: str):
        &#34;&#34;&#34;
        Generates logger for use in the modules.

        Args:
            logger_name (string): name of the logger
        Returns:
            logger: returns logger for module
        &#34;&#34;&#34;
        # Initialize the terminal for color
        colorama.init(autoreset=True)
        logger = logging.getLogger(logger_name)
        console_handler = self.get_console_handler()
        file_handler = self.get_file_handler()
        self.add_handlers(logger, [console_handler, file_handler])
        logger.propagate = False
        return logger

    def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
        &#34;&#34;&#34; Sets ups a new logger &#34;&#34;&#34;
        # create a new logger with name &#39;example&#39;
        logger = self.get_logger(logger_name)

        # set the logging level and formatter for the new logger
        if not verbose:
            logger.setLevel(debug_level_non_verbose)
        else:
            logger.setLevel(debug_level_verbose)

        formatter = logging.Formatter(
            &#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#34;
        )

        console_handler = self.get_console_handler()
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)

    def set_debug_mode(self, debug_mode: bool):
        &#34;&#34;&#34;
        Function to set the root level logging to be debug level to be carried forward throughout

        Args:
            debug_mode (bool): debug mode initiation if true

        Returns:

        &#34;&#34;&#34;
        if debug_mode:
            logging.root.setLevel(logging.DEBUG)

    def get_log_level(self, level: int):
        &#34;&#34;&#34;
        Returns the log level legend
        Values:
            CRITICAL: 50
            ERROR: 40
            WARNING: 30
            INFO: 20
            DEBUG: 10
            NOTSET: 0

        Args:
            level:

        Returns:
            Log level
        &#34;&#34;&#34;
        return logging.getLevelName(level)

    def add_level_name(self, level: int, level_name: str) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout

        Args:
            level:
            level_name:

        Returns:

        &#34;&#34;&#34;
        logging.addLevelName(level, level_name)

    def get_level_name(self, level_name: str) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout

        Args:
            level_name:

        Returns:

        &#34;&#34;&#34;
        logging.getLevelName(level_name)

    def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
        &#34;&#34;&#34;
        Filters log messages from a specific module and sets the logging level for that module.

        Args:
            module_name: str The name of the module whose log messages should be filtered.
            log_level: int The minimum logging level for messages to be output.

        Returns:
            None

        Notes:
            This method adds an instance of FilterByModule to the logger associated with the specified module,
            which filters out log messages that originate from that module. It then sets the logging level
            for that logger, which determines which log messages are output to the console or other logging destination.
        &#34;&#34;&#34;
        logger = logging.getLogger(module_name)
        logger.addFilter(logging.Filter(__name__))
        logger.setLevel(log_level)

    def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout.

        Args:
            message (str): The message to log.
            log_type (str): The log type to log
            verbose (bool): Whether to enable verbose logging.
        &#34;&#34;&#34;
        if verbose:
            match log_type:
                case &#34;debug&#34;:
                    logging.debug(message)
                case &#34;info&#34;:
                    msg = &#34;{} {}&#34;.format(Fore.GREEN, message)
                    logging.info(msg)
                case &#34;warning&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.YELLOW, Style.BRIGHT, message)
                    logging.warning(msg)
                case &#34;error&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.RED, Style.BRIGHT, message)
                    logging.error(msg)
                case &#34;exception&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.CYAN, Style.BRIGHT, message)
                    logging.exception(msg)
                case &#34;critical&#34;:
                    msg = &#34;{} {} {} {}&#34;.format(Fore.RED, Back.YELLOW, Style.BRIGHT, message)
                    logging.critical(msg)

                case _:
                    logging.info(message)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.common.logging.logging_setup.FilterByModule"><code class="flex name class">
<span>class <span class="ident">FilterByModule</span></span>
<span>(</span><span>module_name)</span>
</code></dt>
<dd>
<div class="desc"><p>custom filter class called FilterByModule that inherits from logging.Filter. The filter method of this class
is called for each log record, and it returns True if the record should be allowed through, or False if it
should be filtered out.</p>
<p>Initialize a filter.</p>
<p>Initialize with the name of the logger which, together with its
children, will have its events allowed through the filter. If no
name is specified, allow every event.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterByModule(logging.Filter):
    &#34;&#34;&#34;
    custom filter class called FilterByModule that inherits from logging.Filter. The filter method of this class
    is called for each log record, and it returns True if the record should be allowed through, or False if it
    should be filtered out.
    &#34;&#34;&#34;

    def __init__(self, module_name) -&gt; None:
        super().__init__()
        self.module_name = module_name

    def filter(self, record):
        return not record.name.startswith(self.module_name)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>logging.Filter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.common.logging.logging_setup.FilterByModule.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, record)</span>
</code></dt>
<dd>
<div class="desc"><p>Determine if the specified record is to be logged.</p>
<p>Returns True if the record should be logged, or False otherwise.
If deemed appropriate, the record may be modified in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, record):
    return not record.name.startswith(self.module_name)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup"><code class="flex name class">
<span>class <span class="ident">LoggingSetup</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class that sets up and configures logging for an application.</p>
<p>Singleton Logger class. This class is only instantiated ONCE. It is to keep a consistent
criteria for the logger throughout the application if need be called upon.
It serves as the criteria for initiating logger for modules. It creates child loggers.
It's important to note these are child loggers as any changes made to the root logger
can be done.
This class includes methods to set the log level of the root logger, add new loggers,
and print logs of different levels (info, success, debug, exception, error, warning,
and critical). It also includes methods to add and retrieve custom log level names.
The SuccessLevel class is a custom log level used for success messages.</p>
<h2 id="methods">Methods</h2>
<ul>
<li>def get_console_handler(self):
Defines a console handler to come out on the console</li>
<li>def get_file_handler(self):
Defines a file handler to come out on the console.</li>
<li>def add_handlers(self, logger, handler_list: list):
Adds handlers to the logger, checks first if handlers exist to avoid duplication</li>
<li>def get_logger(self, logger_name: str):
Generates logger for use in the modules.</li>
<li>def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
Sets ups a new logger</li>
<li>def set_debug_mode(self, debug_mode: bool):
Function to set the root level logging to be debug level to be carried forward throughout</li>
<li>def get_log_level(self, level: int):
Returns the log level legend</li>
<li>def add_level_name(self, level: int, level_name: str) -&gt; None:
Outputs the received message to stdout</li>
<li>def get_level_name(self, level_name: str) -&gt; None:
Outputs the received message to stdout</li>
<li>def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
Filters log messages from a specific module and sets the logging level for that module</li>
<li>def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
Outputs the received message to stdout.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoggingSetup:
    &#34;&#34;&#34;
    A class that sets up and configures logging for an application.

    Singleton Logger class. This class is only instantiated ONCE. It is to keep a consistent
    criteria for the logger throughout the application if need be called upon.
    It serves as the criteria for initiating logger for modules. It creates child loggers.
    It&#39;s important to note these are child loggers as any changes made to the root logger
    can be done.
    This class includes methods to set the log level of the root logger, add new loggers,
    and print logs of different levels (info, success, debug, exception, error, warning,
    and critical). It also includes methods to add and retrieve custom log level names.
    The SuccessLevel class is a custom log level used for success messages.

    Methods:
        - def get_console_handler(self):
            Defines a console handler to come out on the console
        - def get_file_handler(self):
            Defines a file handler to come out on the console.
        - def add_handlers(self, logger, handler_list: list):
            Adds handlers to the logger, checks first if handlers exist to avoid duplication
        - def get_logger(self, logger_name: str):
            Generates logger for use in the modules.
        - def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
            Sets ups a new logger
        - def set_debug_mode(self, debug_mode: bool):
            Function to set the root level logging to be debug level to be carried forward throughout
        - def get_log_level(self, level: int):
            Returns the log level legend
        - def add_level_name(self, level: int, level_name: str) -&gt; None:
            Outputs the received message to stdout
        - def get_level_name(self, level_name: str) -&gt; None:
            Outputs the received message to stdout
        - def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
            Filters log messages from a specific module and sets the logging level for that module
        - def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
            Outputs the received message to stdout.
    &#34;&#34;&#34;

    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls.debug_mode = logging_constants.debug_mode_flag
            cls.formatter = logging.Formatter(logging_constants.default_logger_format)
            cls.log_file = logging_constants.log_filename

        return cls._instance

    def get_console_handler(self):
        &#34;&#34;&#34;
        Defines a console handler to come out on the console

        Returns:
            logging handler object : the console handler
        &#34;&#34;&#34;
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(self.formatter)
        console_handler.name = &#34;consoleHandler&#34;
        return console_handler

    def get_file_handler(self):
        &#34;&#34;&#34;
        Defines a file handler to come out on the console.

        Returns:
            logging handler object : the console handler
        &#34;&#34;&#34;
        file_handler = handlers.RotatingFileHandler(
            &#34;./output/logging_logs/&#34; + self.log_file, maxBytes=5000, backupCount=1
        )
        file_handler.setFormatter(self.formatter)
        file_handler.name = &#34;fileHandler&#34;
        return file_handler

    def add_handlers(self, logger, handler_list: list):
        &#34;&#34;&#34;
        Adds handlers to the logger, checks first if handlers exist to avoid
        duplication

        Args:
            logger: Logger to check handlers&#39;
            handler_list: list of handlers to add
        &#34;&#34;&#34;
        existing_handler_names = []
        for existing_handler in logger.handlers:
            existing_handler_names.append(existing_handler.name)

        for new_handler in handler_list:
            if new_handler.name not in existing_handler_names:
                logger.addHandler(new_handler)

    def get_logger(self, logger_name: str):
        &#34;&#34;&#34;
        Generates logger for use in the modules.

        Args:
            logger_name (string): name of the logger
        Returns:
            logger: returns logger for module
        &#34;&#34;&#34;
        # Initialize the terminal for color
        colorama.init(autoreset=True)
        logger = logging.getLogger(logger_name)
        console_handler = self.get_console_handler()
        file_handler = self.get_file_handler()
        self.add_handlers(logger, [console_handler, file_handler])
        logger.propagate = False
        return logger

    def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
        &#34;&#34;&#34; Sets ups a new logger &#34;&#34;&#34;
        # create a new logger with name &#39;example&#39;
        logger = self.get_logger(logger_name)

        # set the logging level and formatter for the new logger
        if not verbose:
            logger.setLevel(debug_level_non_verbose)
        else:
            logger.setLevel(debug_level_verbose)

        formatter = logging.Formatter(
            &#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#34;
        )

        console_handler = self.get_console_handler()
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)

    def set_debug_mode(self, debug_mode: bool):
        &#34;&#34;&#34;
        Function to set the root level logging to be debug level to be carried forward throughout

        Args:
            debug_mode (bool): debug mode initiation if true

        Returns:

        &#34;&#34;&#34;
        if debug_mode:
            logging.root.setLevel(logging.DEBUG)

    def get_log_level(self, level: int):
        &#34;&#34;&#34;
        Returns the log level legend
        Values:
            CRITICAL: 50
            ERROR: 40
            WARNING: 30
            INFO: 20
            DEBUG: 10
            NOTSET: 0

        Args:
            level:

        Returns:
            Log level
        &#34;&#34;&#34;
        return logging.getLevelName(level)

    def add_level_name(self, level: int, level_name: str) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout

        Args:
            level:
            level_name:

        Returns:

        &#34;&#34;&#34;
        logging.addLevelName(level, level_name)

    def get_level_name(self, level_name: str) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout

        Args:
            level_name:

        Returns:

        &#34;&#34;&#34;
        logging.getLevelName(level_name)

    def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
        &#34;&#34;&#34;
        Filters log messages from a specific module and sets the logging level for that module.

        Args:
            module_name: str The name of the module whose log messages should be filtered.
            log_level: int The minimum logging level for messages to be output.

        Returns:
            None

        Notes:
            This method adds an instance of FilterByModule to the logger associated with the specified module,
            which filters out log messages that originate from that module. It then sets the logging level
            for that logger, which determines which log messages are output to the console or other logging destination.
        &#34;&#34;&#34;
        logger = logging.getLogger(module_name)
        logger.addFilter(logging.Filter(__name__))
        logger.setLevel(log_level)

    def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
        &#34;&#34;&#34;
        Outputs the received message to stdout.

        Args:
            message (str): The message to log.
            log_type (str): The log type to log
            verbose (bool): Whether to enable verbose logging.
        &#34;&#34;&#34;
        if verbose:
            match log_type:
                case &#34;debug&#34;:
                    logging.debug(message)
                case &#34;info&#34;:
                    msg = &#34;{} {}&#34;.format(Fore.GREEN, message)
                    logging.info(msg)
                case &#34;warning&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.YELLOW, Style.BRIGHT, message)
                    logging.warning(msg)
                case &#34;error&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.RED, Style.BRIGHT, message)
                    logging.error(msg)
                case &#34;exception&#34;:
                    msg = &#34;{} {} {}&#34;.format(Fore.CYAN, Style.BRIGHT, message)
                    logging.exception(msg)
                case &#34;critical&#34;:
                    msg = &#34;{} {} {} {}&#34;.format(Fore.RED, Back.YELLOW, Style.BRIGHT, message)
                    logging.critical(msg)

                case _:
                    logging.info(message)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.common.logging.logging_setup.LoggingSetup.add_handlers"><code class="name flex">
<span>def <span class="ident">add_handlers</span></span>(<span>self, logger, handler_list: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds handlers to the logger, checks first if handlers exist to avoid
duplication</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger</code></strong></dt>
<dd>Logger to check handlers'</dd>
<dt><strong><code>handler_list</code></strong></dt>
<dd>list of handlers to add</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_handlers(self, logger, handler_list: list):
    &#34;&#34;&#34;
    Adds handlers to the logger, checks first if handlers exist to avoid
    duplication

    Args:
        logger: Logger to check handlers&#39;
        handler_list: list of handlers to add
    &#34;&#34;&#34;
    existing_handler_names = []
    for existing_handler in logger.handlers:
        existing_handler_names.append(existing_handler.name)

    for new_handler in handler_list:
        if new_handler.name not in existing_handler_names:
            logger.addHandler(new_handler)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.add_level_name"><code class="name flex">
<span>def <span class="ident">add_level_name</span></span>(<span>self, level: int, level_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs the received message to stdout</p>
<h2 id="args">Args</h2>
<p>level:
level_name:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_level_name(self, level: int, level_name: str) -&gt; None:
    &#34;&#34;&#34;
    Outputs the received message to stdout

    Args:
        level:
        level_name:

    Returns:

    &#34;&#34;&#34;
    logging.addLevelName(level, level_name)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.get_console_handler"><code class="name flex">
<span>def <span class="ident">get_console_handler</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a console handler to come out on the console</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logging handler object </code></dt>
<dd>the console handler</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_console_handler(self):
    &#34;&#34;&#34;
    Defines a console handler to come out on the console

    Returns:
        logging handler object : the console handler
    &#34;&#34;&#34;
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(self.formatter)
    console_handler.name = &#34;consoleHandler&#34;
    return console_handler</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.get_file_handler"><code class="name flex">
<span>def <span class="ident">get_file_handler</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines a file handler to come out on the console.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logging handler object </code></dt>
<dd>the console handler</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_handler(self):
    &#34;&#34;&#34;
    Defines a file handler to come out on the console.

    Returns:
        logging handler object : the console handler
    &#34;&#34;&#34;
    file_handler = handlers.RotatingFileHandler(
        &#34;./output/logging_logs/&#34; + self.log_file, maxBytes=5000, backupCount=1
    )
    file_handler.setFormatter(self.formatter)
    file_handler.name = &#34;fileHandler&#34;
    return file_handler</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.get_level_name"><code class="name flex">
<span>def <span class="ident">get_level_name</span></span>(<span>self, level_name: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs the received message to stdout</p>
<h2 id="args">Args</h2>
<p>level_name:
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_level_name(self, level_name: str) -&gt; None:
    &#34;&#34;&#34;
    Outputs the received message to stdout

    Args:
        level_name:

    Returns:

    &#34;&#34;&#34;
    logging.getLevelName(level_name)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.get_log_level"><code class="name flex">
<span>def <span class="ident">get_log_level</span></span>(<span>self, level: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the log level legend</p>
<h2 id="values">Values</h2>
<p>CRITICAL: 50
ERROR: 40
WARNING: 30
INFO: 20
DEBUG: 10
NOTSET: 0</p>
<h2 id="args">Args</h2>
<p>level:</p>
<h2 id="returns">Returns</h2>
<p>Log level</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_log_level(self, level: int):
    &#34;&#34;&#34;
    Returns the log level legend
    Values:
        CRITICAL: 50
        ERROR: 40
        WARNING: 30
        INFO: 20
        DEBUG: 10
        NOTSET: 0

    Args:
        level:

    Returns:
        Log level
    &#34;&#34;&#34;
    return logging.getLevelName(level)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.get_logger"><code class="name flex">
<span>def <span class="ident">get_logger</span></span>(<span>self, logger_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates logger for use in the modules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>logger_name</code></strong> :&ensp;<code>string</code></dt>
<dd>name of the logger</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>logger</code></dt>
<dd>returns logger for module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logger(self, logger_name: str):
    &#34;&#34;&#34;
    Generates logger for use in the modules.

    Args:
        logger_name (string): name of the logger
    Returns:
        logger: returns logger for module
    &#34;&#34;&#34;
    # Initialize the terminal for color
    colorama.init(autoreset=True)
    logger = logging.getLogger(logger_name)
    console_handler = self.get_console_handler()
    file_handler = self.get_file_handler()
    self.add_handlers(logger, [console_handler, file_handler])
    logger.propagate = False
    return logger</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.print_log"><code class="name flex">
<span>def <span class="ident">print_log</span></span>(<span>self, message: str, log_type: str, verbose: bool) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Outputs the received message to stdout.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message to log.</dd>
<dt><strong><code>log_type</code></strong> :&ensp;<code>str</code></dt>
<dd>The log type to log</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to enable verbose logging.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_log(self, message: str, log_type: str, verbose: bool) -&gt; None:
    &#34;&#34;&#34;
    Outputs the received message to stdout.

    Args:
        message (str): The message to log.
        log_type (str): The log type to log
        verbose (bool): Whether to enable verbose logging.
    &#34;&#34;&#34;
    if verbose:
        match log_type:
            case &#34;debug&#34;:
                logging.debug(message)
            case &#34;info&#34;:
                msg = &#34;{} {}&#34;.format(Fore.GREEN, message)
                logging.info(msg)
            case &#34;warning&#34;:
                msg = &#34;{} {} {}&#34;.format(Fore.YELLOW, Style.BRIGHT, message)
                logging.warning(msg)
            case &#34;error&#34;:
                msg = &#34;{} {} {}&#34;.format(Fore.RED, Style.BRIGHT, message)
                logging.error(msg)
            case &#34;exception&#34;:
                msg = &#34;{} {} {}&#34;.format(Fore.CYAN, Style.BRIGHT, message)
                logging.exception(msg)
            case &#34;critical&#34;:
                msg = &#34;{} {} {} {}&#34;.format(Fore.RED, Back.YELLOW, Style.BRIGHT, message)
                logging.critical(msg)

            case _:
                logging.info(message)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.set_debug_mode"><code class="name flex">
<span>def <span class="ident">set_debug_mode</span></span>(<span>self, debug_mode: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to set the root level logging to be debug level to be carried forward throughout</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>debug_mode</code></strong> :&ensp;<code>bool</code></dt>
<dd>debug mode initiation if true</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_debug_mode(self, debug_mode: bool):
    &#34;&#34;&#34;
    Function to set the root level logging to be debug level to be carried forward throughout

    Args:
        debug_mode (bool): debug mode initiation if true

    Returns:

    &#34;&#34;&#34;
    if debug_mode:
        logging.root.setLevel(logging.DEBUG)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.set_logger"><code class="name flex">
<span>def <span class="ident">set_logger</span></span>(<span>self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets ups a new logger</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_logger(self, logger_name: str, debug_level_verbose, debug_level_non_verbose, verbose: bool):
    &#34;&#34;&#34; Sets ups a new logger &#34;&#34;&#34;
    # create a new logger with name &#39;example&#39;
    logger = self.get_logger(logger_name)

    # set the logging level and formatter for the new logger
    if not verbose:
        logger.setLevel(debug_level_non_verbose)
    else:
        logger.setLevel(debug_level_verbose)

    formatter = logging.Formatter(
        &#34;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#34;
    )

    console_handler = self.get_console_handler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)</code></pre>
</details>
</dd>
<dt id="src.common.logging.logging_setup.LoggingSetup.silence_module_output"><code class="name flex">
<span>def <span class="ident">silence_module_output</span></span>(<span>self, module_name: str, log_level: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Filters log messages from a specific module and sets the logging level for that module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module_name</code></strong></dt>
<dd>str The name of the module whose log messages should be filtered.</dd>
<dt><strong><code>log_level</code></strong></dt>
<dd>int The minimum logging level for messages to be output.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="notes">Notes</h2>
<p>This method adds an instance of FilterByModule to the logger associated with the specified module,
which filters out log messages that originate from that module. It then sets the logging level
for that logger, which determines which log messages are output to the console or other logging destination.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def silence_module_output(self, module_name: str, log_level: int) -&gt; None:
    &#34;&#34;&#34;
    Filters log messages from a specific module and sets the logging level for that module.

    Args:
        module_name: str The name of the module whose log messages should be filtered.
        log_level: int The minimum logging level for messages to be output.

    Returns:
        None

    Notes:
        This method adds an instance of FilterByModule to the logger associated with the specified module,
        which filters out log messages that originate from that module. It then sets the logging level
        for that logger, which determines which log messages are output to the console or other logging destination.
    &#34;&#34;&#34;
    logger = logging.getLogger(module_name)
    logger.addFilter(logging.Filter(__name__))
    logger.setLevel(log_level)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.common.logging" href="index.html">src.common.logging</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.common.logging.logging_setup.FilterByModule" href="#src.common.logging.logging_setup.FilterByModule">FilterByModule</a></code></h4>
<ul class="">
<li><code><a title="src.common.logging.logging_setup.FilterByModule.filter" href="#src.common.logging.logging_setup.FilterByModule.filter">filter</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.common.logging.logging_setup.LoggingSetup" href="#src.common.logging.logging_setup.LoggingSetup">LoggingSetup</a></code></h4>
<ul class="">
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.add_handlers" href="#src.common.logging.logging_setup.LoggingSetup.add_handlers">add_handlers</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.add_level_name" href="#src.common.logging.logging_setup.LoggingSetup.add_level_name">add_level_name</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.get_console_handler" href="#src.common.logging.logging_setup.LoggingSetup.get_console_handler">get_console_handler</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.get_file_handler" href="#src.common.logging.logging_setup.LoggingSetup.get_file_handler">get_file_handler</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.get_level_name" href="#src.common.logging.logging_setup.LoggingSetup.get_level_name">get_level_name</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.get_log_level" href="#src.common.logging.logging_setup.LoggingSetup.get_log_level">get_log_level</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.get_logger" href="#src.common.logging.logging_setup.LoggingSetup.get_logger">get_logger</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.print_log" href="#src.common.logging.logging_setup.LoggingSetup.print_log">print_log</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.set_debug_mode" href="#src.common.logging.logging_setup.LoggingSetup.set_debug_mode">set_debug_mode</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.set_logger" href="#src.common.logging.logging_setup.LoggingSetup.set_logger">set_logger</a></code></li>
<li><code><a title="src.common.logging.logging_setup.LoggingSetup.silence_module_output" href="#src.common.logging.logging_setup.LoggingSetup.silence_module_output">silence_module_output</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>